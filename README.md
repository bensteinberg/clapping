clapping
========

This is an experiment in visualizing [Tidal
Cycles](https://tidalcycles.org/) output. The aim was to convince
myself visually that the version of [Steve Reich's "Clapping
Music"](https://en.wikipedia.org/wiki/Clapping_Music) I'd made was
correct. The version as performed with an
[automat](https://dadamachines.com/products/automat-toolkit/), with
four repeats of each cycle, about a minute and a half, is

```
let p = "t t t ~ t t ~ t ~ t t ~"
in d1 $ qtrigger $ seqP [
      (0, 52, struct p $ n "1"),
      (0, 52, repeatCycles 4 $ iter 12 $ struct p $ n "2")
    ] # legato 0.25 # s "dada"
```

and the text output in [clapping.raw](clapping.raw), with a single
repeat per cycle, was generated by evaluating

```
let p = "t t t ~ t t ~ t ~ t t ~"
in writeFile "clapping.raw" $ Sound.Tidal.Show.showAll (Arc 0 13) $ qtrigger $ seqP [
      (0, 52, struct p $ n "1"),
      (0, 52, iter 12 $ struct p $ n "2")
    ]
```

The default action of the [program here](clapping/cli.py) is to
produce a text version of the patterns; after [installing
Poetry](https://python-poetry.org/docs/#installation) and running
`poetry install`, you can run `poetry run transform` to get this:

```
111011010110
111011010110

111011010110
110110101101

111011010110
101101011011

111011010110
011010110111

111011010110
110101101110

111011010110
101011011101

111011010110
010110111011

111011010110
101101110110

111011010110
011011101101

111011010110
110111011010

111011010110
101110110101

111011010110
011101101011

111011010110
111011010110
```

After installing [LilyPond](https://lilypond.org/), running `poetry
run transform --out lilypond` produces [clapping.ly](clapping.ly),
(mis)using LilyPond's `congas-style`, and then
[clapping.pdf](clapping.pdf).

(A couple of days before I got this working, I used the [didactic
pattern
visualizer](https://github.com/ivan-abreu/didacticpatternvisualizer)
to show the correctness of the score dynamically.)

This code is not useful as is for generating scores from arbitrary
Tidal Cycles patterns, but it could probably be generalized; a better
bet would probably be to implement an events-to-LilyPond transformer
in Haskell.
